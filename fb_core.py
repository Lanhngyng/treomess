import requests 
import re
import time
import gc
import psutil
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed 
MAX_WORKERS = 8 # so cookie chay song song def write_log(msg): with open("log.txt", "a", encoding="utf-8") as f: f.write(f"[{datetime.now()}] {msg}\n") def save_die_cookie(cookie): with open("cookie_die.txt", "a", encoding="utf-8") as f: f.write(cookie + "\n") class FB: def __init__(self, cookie, name): self.cookie = cookie self.name = name self.uid = self.get_uid() self.fb_dtsg = None self.s = requests.Session() self.s.headers.update({ "Cookie": self.cookie, "User-Agent": "Mozilla/5.0" }) self.refresh_token() def get_uid(self): m = re.search(r"c_user=(\d+)", self.cookie) if not m: raise Exception("Cookie khong hop le") return m.group(1) def refresh_token(self): urls = [ "https://mbasic.facebook.com", "https://m.facebook.com", "https://www.facebook.com" ] for u in urls: try: r = self.s.get(u, timeout=10) m = re.search(r'name="fb_dtsg" value="(.*?)"', r.text) if m: self.fb_dtsg = m.group(1) return except: pass raise Exception("Khong lay duoc fb_dtsg") def send(self, thread_id, msg): ts = int(time.time() * 1000) data = { "thread_fbid": thread_id, "action_type": "ma-type:user-generated-message", "body": msg, "author": f"fbid:{self.uid}", "timestamp": ts, "offline_threading_id": str(ts), "message_id": str(ts), "__user": self.uid, "__a": "1", "fb_dtsg": self.fb_dtsg } r = self.s.post( "https://www.facebook.com/messaging/send/", data=data, timeout=10 ) if r.status_code != 200: return False, "HTTP " + str(r.status_code) if "error" in r.text.lower(): return False, "FB ERROR" return True, None def worker(cookie, name, threads, msg, delay): try: fb = FB(cookie, name) except Exception: print(f"[X] {name} cookie die") save_die_cookie(cookie) return for tid in threads: try: ok, err = fb.send(tid, msg) if not ok and "fb" in str(err).lower(): fb.refresh_token() ok, err = fb.send(tid, msg) if ok: print(f"[✓] {name} -> {tid}") write_log(f"{name} OK {tid}") else: print(f"[X] {name} -> {tid} | {err}") write_log(f"{name} LOI {tid} {err}") time.sleep(delay) except Exception as e: print(f"[X] {name} loi bat thuong") write_log(f"{name} exception {e}") gc.collect() def main(): # ===== DOC COOKIE ===== try: with open("cookie.txt", "r", encoding="utf-8") as f: cookies = [c.strip() for c in f if c.strip()] except: print("[!] Khong mo duoc cookie.txt") return if not cookies: print("[!] cookie.txt rong") return # ===== NHAP BOX ===== threads = input("[+] Nhap ID box (cach nhau ,): ").split(",") threads = [t.strip() for t in threads if t.strip()] if not threads: print("[!] Chua nhap box") return # ===== DOC NOI DUNG ===== try: with open("message.txt", "r", encoding="utf-8") as f: msg = f.read().strip() except: print("[!] Khong mo duoc message.txt") return # ===== NHAP DELAY CHUNG ===== try: delay = float(input("[+] Nhap delay dung chung cho tat ca cookie (giay): ")) except: print("[!] Delay khong hop le") return print(f"\n[✓] Cookie: {len(cookies)} | Song song: {MAX_WORKERS} | Delay: {delay}s\n") with ThreadPoolExecutor(max_workers=MAX_WORKERS) as exe: jobs = [] for i, ck in enumerate(cookies, 1): jobs.append( exe.submit(worker, ck, f"cookie_{i}", threads, msg, delay) ) for _ in as_completed(jobs): pass mem = psutil.virtual_memory() print(f"\n[RAM] {mem.percent}% | DONE") if __name__ == "__main__": main()
